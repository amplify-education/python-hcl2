# pylint: disable=missing-function-docstring,unused-argument
from lark import Token, Tree, v_args, Transformer, Discard
from lark.tree import Meta

from hcl2.rule_transformer.rules.base import (
    StartRule,
    BodyRule,
    BlockRule,
    AttributeRule,
)
from hcl2.rule_transformer.rules.containers import (
    ObjectRule,
    ObjectElemRule,
    ObjectElemKeyRule,
    TupleRule,
    ObjectElemKeyExpressionRule,
    ObjectElemKeyDotAccessor,
)
from hcl2.rule_transformer.rules.expressions import (
    BinaryTermRule,
    UnaryOpRule,
    BinaryOpRule,
    ExprTermRule,
    ConditionalRule,
)
from hcl2.rule_transformer.rules.for_expressions import (
    ForTupleExprRule,
    ForObjectExprRule,
    ForIntroRule,
    ForCondRule,
)
from hcl2.rule_transformer.rules.functions import ArgumentsRule, FunctionCallRule
from hcl2.rule_transformer.rules.indexing import (
    IndexExprTermRule,
    SqbIndexRule,
    ShortIndexRule,
    GetAttrRule,
    GetAttrExprTermRule,
    AttrSplatExprTermRule,
    AttrSplatRule,
    FullSplatRule,
    FullSplatExprTermRule,
)
from hcl2.rule_transformer.rules.literal_rules import (
    FloatLitRule,
    IntLitRule,
    IdentifierRule,
    BinaryOperatorRule,
    KeywordRule,
)
from hcl2.rule_transformer.rules.strings import (
    InterpolationRule,
    StringRule,
    StringPartRule,
    HeredocTemplateRule,
    HeredocTrimTemplateRule,
)
from hcl2.rule_transformer.rules.tokens import (
    NAME,
    IntLiteral,
    FloatLiteral,
    StringToken,
)
from hcl2.rule_transformer.rules.whitespace import NewLineOrCommentRule


class RuleTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a tree of LarkRule instances
    """

    with_meta: bool

    def transform(self, tree: Tree) -> StartRule:
        return super().transform(tree)

    def __init__(self, discard_new_line_or_comments: bool = False):
        super().__init__()
        self.discard_new_line_or_comments = discard_new_line_or_comments

    def __default_token__(self, token: Token) -> StringToken:
        # TODO make this return StaticStringToken where applicable
        return StringToken[token.type](token.value)

    def FLOAT_LITERAL(self, token: Token) -> FloatLiteral:
        return FloatLiteral(token.value)

    def NAME(self, token: Token) -> NAME:
        return NAME(token.value)

    def INT_LITERAL(self, token: Token) -> IntLiteral:
        return IntLiteral(token.value)

    @v_args(meta=True)
    def start(self, meta: Meta, args) -> StartRule:
        return StartRule(args, meta)

    @v_args(meta=True)
    def body(self, meta: Meta, args) -> BodyRule:
        return BodyRule(args, meta)

    @v_args(meta=True)
    def block(self, meta: Meta, args) -> BlockRule:
        return BlockRule(args, meta)

    @v_args(meta=True)
    def attribute(self, meta: Meta, args) -> AttributeRule:
        return AttributeRule(args, meta)

    @v_args(meta=True)
    def new_line_or_comment(self, meta: Meta, args) -> NewLineOrCommentRule:
        if self.discard_new_line_or_comments:
            return Discard
        return NewLineOrCommentRule(args, meta)

    @v_args(meta=True)
    def identifier(self, meta: Meta, args) -> IdentifierRule:
        return IdentifierRule(args, meta)

    @v_args(meta=True)
    def keyword(self, meta: Meta, args) -> KeywordRule:
        return KeywordRule(args, meta)

    @v_args(meta=True)
    def int_lit(self, meta: Meta, args) -> IntLitRule:
        return IntLitRule(args, meta)

    @v_args(meta=True)
    def float_lit(self, meta: Meta, args) -> FloatLitRule:
        return FloatLitRule(args, meta)

    @v_args(meta=True)
    def string(self, meta: Meta, args) -> StringRule:
        return StringRule(args, meta)

    @v_args(meta=True)
    def string_part(self, meta: Meta, args) -> StringPartRule:
        return StringPartRule(args, meta)

    @v_args(meta=True)
    def interpolation(self, meta: Meta, args) -> InterpolationRule:
        return InterpolationRule(args, meta)

    @v_args(meta=True)
    def heredoc_template(self, meta: Meta, args) -> HeredocTemplateRule:
        return HeredocTemplateRule(args, meta)

    @v_args(meta=True)
    def heredoc_template_trim(self, meta: Meta, args) -> HeredocTrimTemplateRule:
        return HeredocTrimTemplateRule(args, meta)

    @v_args(meta=True)
    def expr_term(self, meta: Meta, args) -> ExprTermRule:
        return ExprTermRule(args, meta)

    @v_args(meta=True)
    def conditional(self, meta: Meta, args) -> ConditionalRule:
        return ConditionalRule(args, meta)

    @v_args(meta=True)
    def binary_operator(self, meta: Meta, args) -> BinaryOperatorRule:
        return BinaryOperatorRule(args, meta)

    @v_args(meta=True)
    def binary_term(self, meta: Meta, args) -> BinaryTermRule:
        return BinaryTermRule(args, meta)

    @v_args(meta=True)
    def unary_op(self, meta: Meta, args) -> UnaryOpRule:
        return UnaryOpRule(args, meta)

    @v_args(meta=True)
    def binary_op(self, meta: Meta, args) -> BinaryOpRule:
        return BinaryOpRule(args, meta)

    @v_args(meta=True)
    def tuple(self, meta: Meta, args) -> TupleRule:
        return TupleRule(args, meta)

    @v_args(meta=True)
    def object(self, meta: Meta, args) -> ObjectRule:
        return ObjectRule(args, meta)

    @v_args(meta=True)
    def object_elem(self, meta: Meta, args) -> ObjectElemRule:
        return ObjectElemRule(args, meta)

    @v_args(meta=True)
    def object_elem_key(self, meta: Meta, args) -> ObjectElemKeyRule:
        return ObjectElemKeyRule(args, meta)

    @v_args(meta=True)
    def object_elem_key_expression(
        self, meta: Meta, args
    ) -> ObjectElemKeyExpressionRule:
        return ObjectElemKeyExpressionRule(args, meta)

    @v_args(meta=True)
    def object_elem_key_dot_accessor(
        self, meta: Meta, args
    ) -> ObjectElemKeyDotAccessor:
        return ObjectElemKeyDotAccessor(args, meta)

    @v_args(meta=True)
    def arguments(self, meta: Meta, args) -> ArgumentsRule:
        return ArgumentsRule(args, meta)

    @v_args(meta=True)
    def function_call(self, meta: Meta, args) -> FunctionCallRule:
        return FunctionCallRule(args, meta)

    # @v_args(meta=True)
    # def provider_function_call(self, meta: Meta, args) -> ProviderFunctionCallRule:
    #     return ProviderFunctionCallRule(args, meta)

    @v_args(meta=True)
    def index_expr_term(self, meta: Meta, args) -> IndexExprTermRule:
        return IndexExprTermRule(args, meta)

    @v_args(meta=True)
    def braces_index(self, meta: Meta, args) -> SqbIndexRule:
        return SqbIndexRule(args, meta)

    @v_args(meta=True)
    def short_index(self, meta: Meta, args) -> ShortIndexRule:
        return ShortIndexRule(args, meta)

    @v_args(meta=True)
    def get_attr(self, meta: Meta, args) -> GetAttrRule:
        return GetAttrRule(args, meta)

    @v_args(meta=True)
    def get_attr_expr_term(self, meta: Meta, args) -> GetAttrExprTermRule:
        return GetAttrExprTermRule(args, meta)

    @v_args(meta=True)
    def attr_splat(self, meta: Meta, args) -> AttrSplatRule:
        return AttrSplatRule(args, meta)

    @v_args(meta=True)
    def attr_splat_expr_term(self, meta: Meta, args) -> AttrSplatExprTermRule:
        return AttrSplatExprTermRule(args, meta)

    @v_args(meta=True)
    def full_splat(self, meta: Meta, args) -> FullSplatRule:
        return FullSplatRule(args, meta)

    @v_args(meta=True)
    def full_splat_expr_term(self, meta: Meta, args) -> FullSplatExprTermRule:
        return FullSplatExprTermRule(args, meta)

    @v_args(meta=True)
    def for_tuple_expr(self, meta: Meta, args) -> ForTupleExprRule:
        return ForTupleExprRule(args, meta)

    @v_args(meta=True)
    def for_object_expr(self, meta: Meta, args) -> ForObjectExprRule:
        return ForObjectExprRule(args, meta)

    @v_args(meta=True)
    def for_intro(self, meta: Meta, args) -> ForIntroRule:
        return ForIntroRule(args, meta)

    @v_args(meta=True)
    def for_cond(self, meta: Meta, args) -> ForCondRule:
        return ForCondRule(args, meta)
