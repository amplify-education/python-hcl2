# pylint: disable=missing-function-docstring,unused-argument
from typing import List, Union

from lark import Transformer, Tree, Token
from lark.tree import Meta
from lark.visitors import _Leaf_T, Discard, v_args

from hcl2.rule_transformer.rules.abstract import LarkToken, LarkRule
from hcl2.rule_transformer.rules.base import (
    StartRule,
    BodyRule,
    BlockRule,
    AttributeRule,
)
from hcl2.rule_transformer.rules.expression import (
    BinaryTermRule,
    ConditionalRule,
    ExprTermRule,
    BinaryOpRule,
    UnaryOpRule,
)
from hcl2.rule_transformer.rules.token_sequence import (
    IdentifierRule,
    IntLitRule,
    FloatLitRule,
    StringLitRule,
    BinaryOperatorRule,
)
from hcl2.rule_transformer.rules.whitespace import NewLineOrCommentRule


class RuleTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a tree of LarkRule instances
    """

    with_meta: bool

    @staticmethod
    def is_type_keyword(value: str) -> bool:
        return value in {"bool", "number", "string"}

    def __init__(self, with_meta: bool = False, with_comments: bool = True):
        """
        :param with_meta: If set to true then adds `__start_line__` and `__end_line__`
        parameters to the output dict. Default to false.
        """
        self._with_meta = with_meta
        self._with_comments = with_comments
        super().__init__()

    def transform(self, tree: Tree[_Leaf_T]) -> LarkRule:
        return super().transform(tree)

    def __default_token__(self, token: Token) -> LarkToken:
        return LarkToken(token.type, token.value)

    @v_args(meta=True)
    def start(self, meta: Meta, args) -> StartRule:
        return StartRule(args, meta)

    @v_args(meta=True)
    def body(self, meta: Meta, args) -> BodyRule:
        return BodyRule(args, meta)

    @v_args(meta=True)
    def block(self, meta: Meta, args) -> BlockRule:
        return BlockRule(args, meta)

    @v_args(meta=True)
    def identifier(self, meta: Meta, args) -> IdentifierRule:
        return IdentifierRule(args, meta)

    @v_args(meta=True)
    def int_lit(self, meta: Meta, args) -> IntLitRule:
        return IntLitRule(args, meta)

    @v_args(meta=True)
    def float_lit(self, meta: Meta, args) -> FloatLitRule:
        return FloatLitRule(args, meta)

    @v_args(meta=True)
    def string_lit(self, meta: Meta, args) -> StringLitRule:
        return StringLitRule(args, meta)

    @v_args(meta=True)
    def expr_term(self, meta: Meta, args) -> ExprTermRule:
        return ExprTermRule(args, meta)

    @v_args(meta=True)
    def conditional(self, meta: Meta, args) -> ConditionalRule:
        return ConditionalRule(args, meta)

    @v_args(meta=True)
    def binary_operator(self, meta: Meta, args) -> BinaryOperatorRule:
        return BinaryOperatorRule(args, meta)

    @v_args(meta=True)
    def binary_term(self, meta: Meta, args) -> BinaryTermRule:
        return BinaryTermRule(args, meta)

    @v_args(meta=True)
    def unary_op(self, meta: Meta, args) -> UnaryOpRule:
        return UnaryOpRule(args, meta)

    @v_args(meta=True)
    def binary_op(self, meta: Meta, args) -> BinaryOpRule:
        return BinaryOpRule(args, meta)

    @v_args(meta=True)
    def attribute(self, meta: Meta, args) -> AttributeRule:
        return AttributeRule(args, meta)

    @v_args(meta=True)
    def new_line_or_comment(self, meta: Meta, args) -> NewLineOrCommentRule:
        if self._with_comments:
            return NewLineOrCommentRule(args, meta)
        return Discard
