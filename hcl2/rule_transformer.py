# pylint: disable=missing-function-docstring,unused-argument
from typing import List, Union

from lark import Transformer, Tree, Token
from lark.visitors import _Leaf_T, _Return_T, Discard

from hcl2.serialization import (
    LarkRule,
    LarkToken,
    StartRule,
    BodyRule,
    BlockRule,
    IdentifierRule,
    IntLitRule,
    FloatLitRule,
    StringLitRule,
    ExprTermRule,
    ConditionalRule,
    BinaryOpRule,
    BinaryOperatorRule,
    BinaryTermRule,
    UnaryOpRule,
    AttributeRule,
    NewLineOrCommentRule,
)

ArgsType = List[Union[Token, Tree]]


class RuleTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a tree of LarkRule instances
    """

    with_meta: bool

    @staticmethod
    def is_type_keyword(value: str) -> bool:
        return value in {"bool", "number", "string"}

    def __init__(self, with_meta: bool = False, with_comments: bool = True):
        """
        :param with_meta: If set to true then adds `__start_line__` and `__end_line__`
        parameters to the output dict. Default to false.
        """
        self._with_meta = with_meta
        self._with_comments = with_comments
        super().__init__()

    def start(self, args: ArgsType) -> StartRule:
        return StartRule(args)

    def body(self, args: ArgsType) -> BodyRule:
        return BodyRule(args)

    def block(self, args: ArgsType) -> BlockRule:
        return BlockRule(args)

    def identifier(self, args: ArgsType) -> IdentifierRule:
        return IdentifierRule(args)

    def int_lit(self, args: ArgsType) -> IntLitRule:
        return IntLitRule(args)

    def float_lit(self, args: ArgsType) -> FloatLitRule:
        return FloatLitRule(args)

    def string_lit(self, args: ArgsType) -> StringLitRule:
        return StringLitRule(args)

    def expr_term(self, args: ArgsType) -> ExprTermRule:
        return ExprTermRule(args)

    def conditional(self, args: ArgsType) -> ConditionalRule:
        return ConditionalRule(args)

    def binary_operator(self, args: ArgsType) -> BinaryOperatorRule:
        return BinaryOperatorRule(args)

    def binary_term(self, args: ArgsType) -> BinaryTermRule:
        return BinaryTermRule(args)

    def unary_op(self, args: ArgsType) -> UnaryOpRule:
        return UnaryOpRule(args)

    def binary_op(self, args: ArgsType) -> BinaryOpRule:
        return BinaryOpRule(args)

    def attribute(self, args: ArgsType) -> AttributeRule:
        return AttributeRule(args)

    def new_line_or_comment(self, args: ArgsType) -> NewLineOrCommentRule:
        if self._with_comments:
            return NewLineOrCommentRule(args)
        return Discard

    def transform(self, tree: Tree[_Leaf_T]) -> LarkRule:
        return super().transform(tree)

    def __default_token__(self, token: Token) -> LarkToken:
        return LarkToken(token.type, token.value)
